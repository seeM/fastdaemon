# AUTOGENERATED! DO NOT EDIT! File to edit: ../01_server.ipynb.

# %% auto 0
__all__ = ['DaemonHandler', 'DaemonServer', 'fastdaemon_serve']

# %% ../01_server.ipynb 2
import socket
from contextlib import redirect_stderr, redirect_stdout
from io import StringIO
from multiprocessing import get_context
from socketserver import TCPServer, StreamRequestHandler

from fastcore.meta import *
from fastcore.net import *
from fastcore.script import *
from fastcore.utils import *

from .core import *

# %% ../01_server.ipynb 5
def _handle(cmd, stdin, args):
    "Execute `cmd` with `stdin` and `args`, and return `stdout`"
    sys.argv = [cmd.__name__] + (args.split(' ') if args else [])
    sys.stdin,sys_stdin = StringIO(stdin),sys.stdin
    with redirect_stdout(StringIO()) as stdout, redirect_stderr(StringIO()) as stderr: cmd()
    sys.stdin = sys_stdin
    return stdout.getvalue().encode(),stderr.getvalue().encode()

# %% ../01_server.ipynb 6
class DaemonHandler(StreamRequestHandler):
    "Execute server's `cmd` with request args using server's process pool"
    def handle(self):
        stdin,args = recv_strings(self.rfile.read)
#         print(f'{stdin=} {args=}')
        print(f'{args=}')
        future = self.server.pool.submit(_handle, self.server.cmd, stdin, args)
        stdout, stderr = future.result()
#         print(f'{stdout=} {stderr=}')
        send_strings(self.wfile.write, (stdout,stderr))

# %% ../01_server.ipynb 8
class DaemonServer(TCPServer): # TODO: could be a mixin to support other servers; `Pool(ed)Server`?
    "A `TCPServer` that executes `cmd` with request args using a process pool"
    @delegates(TCPServer)
    def __init__(self, server_address, cmd, RequestHandlerClass=DaemonHandler, timeout=None, **kwargs):
        self.cmd = cmd # TODO: is this the best place for `cmd`?
        if timeout is not None: self.timeout = timeout
        self.allow_reuse_address = True
        super().__init__(server_address, RequestHandlerClass)
        
    def server_activate(self):
        self.pool = ProcessPoolExecutor(mp_context=get_context('fork')) # TODO: make ctx configurable?
        super().server_activate()
        
    def server_close(self):
        if hasattr(self,'pool'): self.pool.shutdown()
        super().server_close()
        
    def handle_timeout(self): return True

# %% ../01_server.ipynb 15
def fastdaemon_serve(cmd, port, host=None, timeout=None):
    "Serve `cmd` on `port`, with optional `host` and `timeout`"
    host = host or socket.gethostname()
    with DaemonServer((host,port), cmd, timeout=timeout) as srv:
        while not srv.handle_request(): pass
